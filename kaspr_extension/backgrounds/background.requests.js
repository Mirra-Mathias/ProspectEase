import { getToken, capitalizeFirstLetter, reloadDashboard,notificationsEvent } from "./functions.js";import { REACT_APP_BASE_URL } from "./background.constants.js";import * as api from "./background.api.js";async function onCreateOrganization(token) {  try {    const { data: dataUser, statusCode: userStatusCode } = await api.getUser({      token,    });    const { data, statusCode } = await api.getPublicOrganization({      token,    });    if (      (data.organizations && !data.organizations.length) ||      statusCode !== 200    ) {      let domainName = dataUser.email.split("@")[1];      domainName = domainName.split(".");      domainName.pop();      domainName = domainName.join("");      const organization = {        name: capitalizeFirstLetter(domainName) + " Workspace",        domains: [dataUser.email.split("@")[1]],      };      const formData = new FormData();      formData.append("picture", null);      formData.append("organization", JSON.stringify(organization));      const { statusCode } = await api.createOrganization({        token,        data: formData,      });      return { success: statusCode == 200 };    }  } catch (err) {    return false;  }}/**/getToken().then(({ token, csrf }) => {  chrome.cookies.get(    { url: REACT_APP_BASE_URL, name: "first_install" },    async (firstInstall) => {      let { data } = await api.getUser({ token: token.value });      const linkedinValidation =        data.steps &&        data.steps.find((step) => step.id === "linkedinValidation");      if (linkedinValidation && !linkedinValidation.done && !firstInstall) {        await api.validatePluginInstallation({ token: token.value, csrf });        chrome.tabs.update({          url: "https://www.linkedin.com/feed/?synchro=kaspr&isFirstKasprSynchro=true",        });        chrome.cookies.set({          url: REACT_APP_BASE_URL,          name: "first_install",          value: "true",          expirationDate: new Date().getTime() / 1000 + 3600 * 24 * 30 * 365,        });        reloadDashboard();      }    }  );});chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {  getToken().then((credentials) => {    if (request.action == "GET_TOKEN") {      if (!credentials.token)        return sendResponse({          data: { message: "user not connected" },          statusCode: 400,        });      sendResponse({ token: credentials.token, statusCode: 200 });    }    //    if (!credentials.token) return;    if (request.action == "LINKEDIN_SYNCHRO") {      if (!credentials.token)        return sendResponse({          data: {            message:              "You have to connect to your Kaspr account or you have to accept the permission to use the plugin",            messageVar: "youHaveToConnectToYouKasprAccount",          },          statusCode: 400,        });      api        .linkedinSynchro({          ...request.input,          token: credentials.token.value,          csrf: credentials.csrf,        })        .then(async (data) => {          if (data && data.statusCode == 200) {            await onCreateOrganization(credentials.token.value);            reloadDashboard(              request.input && request.input.isFirstKasprSynchro                ? "firstSync"                : null            );          }          sendResponse(data);        })        .catch((result) => sendResponse(result));    }    if (request.action == "LINKEDIN_CLASSES") {      if (!credentials.token)        return sendResponse({          data: {            message:              "You have to connect to your Kaspr account or you have to accept the permission to use the plugin",            messageVar: "youHaveToConnectToYouKasprAccount",          },          statusCode: 400,        });      api        .linkedinClasses({          ...request.input,          token: credentials.token.value,          csrf: credentials.csrf,        })        .then((data) => {          sendResponse(data);        })        .catch((result) => sendResponse(result));    }    if (request.action == "VALIDATE_LINKEDIN_STEP") {      if (!credentials.token)        return sendResponse({          data: { message: "user not connected" },          statusCode: 400,        });      api        .validateLinkedinStep({          token: credentials.token.value,          csrf: credentials.csrf,        })        .then((data) => {          reloadDashboard();          sendResponse(data);        })        .catch((result) => sendResponse(result));    }    if (request.action == "VALIDATE_PLUGIN_INSTALLATION") {      if (!credentials.token)        return sendResponse({          data: { message: "user not connected" },          statusCode: 400,        });      api        .skipSteps({          token: credentials.token.value,          csrf: credentials.csrf,        })        .then((data) => {          reloadDashboard();          sendResponse(data);        })        .catch((result) => sendResponse(result));    }    if (request.action == "GET_HIDDEN_DATA_PROFILE") {      if (!credentials.token)        return sendResponse({          data: { message: "user not connected" },          statusCode: 400,        });      api        .checkLinkedinProfile({          ...request.input,          token: credentials.token.value,          csrf: credentials.csrf,        })        .then((results) => {          if (results.data && results.data.profile) {            notificationsEvent(              results.data.profile.emails.length +                results.data.profile.phones.length            );          }          sendResponse(results);        })        .catch((result) => sendResponse(result));    }    if (request.action == "ADVANCED_SEARCH") {      if (!credentials.token)        return sendResponse({          data: { message: "user not connected" },          statusCode: 400,        });      api        .advancedSearchLinkedin({          ...request.input,          token: credentials.token.value,          csrf: credentials.csrf,        })        .then((data) => {          sendResponse(data);        })        .catch((result) => sendResponse(result));    }    if (request.action == "GET_DATA_PROFILE") {      if (!credentials.token)        return sendResponse({          data: { message: "user not connected" },          statusCode: 400,        });      api        .getEmailsLinkedin({          ...request.input,          token: credentials.token.value,          csrf: credentials.csrf,        })        .then((data) => {          if (request.input.isFirstDiscover) {            reloadDashboard();          }          sendResponse(data);        })        .catch((result) => sendResponse(result));    }    if (request.action == "GET_HIDDEN_DATA_COMPANY") {      if (!credentials.token)        return sendResponse({          data: { message: "user not connected" },          statusCode: 400,        });      api        .checkLinkedinCompany({          ...request.input,          token: credentials.token.value,          csrf: credentials.csrf,        })        .then((results) => {          if (results.data && results.data.patterns)            notificationsEvent(              results.data.patterns.length + results.data.phones.length            );          sendResponse(results);        })        .catch((result) => sendResponse(result));    }    if (request.action == "GET_DATA_COMPANY") {      if (!credentials.token)        return sendResponse({          data: { message: "user not connected" },          statusCode: 400,        });      api        .getPatternsLinkedin({          ...request.input,          token: credentials.token.value,          csrf: credentials.csrf,        })        .then((data) => {          sendResponse(data);        })        .catch((result) => sendResponse(result));    }    if (request.action == "AUTOMATION_SUBMIT") {      if (!credentials.token)        return sendResponse({          data: { message: "user not connected" },          statusCode: 400,        });      api        .linkedInAutomation({          ...request.input,          token: credentials.token.value,          csrf: credentials.csrf,        })        .then((data) => {          if (request.input.isFirstLaunch) {            reloadDashboard();          }          sendResponse(data);        })        .catch((result) => sendResponse(result));    }    if (request.action == "GET_WORKFLOWS") {      if (!credentials.token)        return sendResponse({          data: { message: "user not connected" },          statusCode: 400,        });      api        .getWorflows({          ...request.input,          token: credentials.token.value,          csrf: credentials.csrf,        })        .then(sendResponse)        .catch((result) => sendResponse(result));    }    if (request.action == "GET_LEADS_LABELS") {      if (!credentials.token)        return sendResponse({          data: { message: "user not connected" },          statusCode: 400,        });      api        .getLabels({          ...request.input,          token: credentials.token.value,          csrf: credentials.csrf,        })        .then(sendResponse)        .catch((result) => sendResponse(result));    }    if (request.action == "GET_COMPANIES") {      if (!credentials.token)        return sendResponse({          data: { message: "user not connected" },          statusCode: 400,        });      api        .getCompanies({          ...request.input,          token: credentials.token.value,          csrf: credentials.csrf,        })        .then(sendResponse)        .catch((result) => sendResponse(result));    }    if (request.action == "UPDATE_USER") {      if (!credentials.token)        return sendResponse({          data: { message: "user not connected" },          statusCode: 400,        });      api        .updateUser({          ...request.input,          token: credentials.token.value,          csrf: credentials.csrf,        })        .then(sendResponse)        .catch((result) => sendResponse(result));    }    if (request.action == "ADD_LEAD") {      if (!credentials.token)        return sendResponse({          data: { message: "user not connected" },          statusCode: 400,        });      api        .addLead({          ...request.input,          token: credentials.token.value,          csrf: credentials.csrf,        })        .then((data) => {          if (request.input.isFirstLeadAdded) {            reloadDashboard();          }          sendResponse(data);        })        .catch((result) => sendResponse(result));    }    if (request.action == "ADD_PRELEAD_TO_WAITING_LIST") {      if (!credentials.token)        return sendResponse({          data: { message: "user not connected" },          statusCode: 400,        });      api        .addPreLeadToWaitingList({          ...request.input,          token: credentials.token.value,          csrf: credentials.csrf,        })        .then(sendResponse)        .catch((result) => sendResponse(result));    }    if (request.action == "UPDATE_LEAD") {      if (!credentials.token)        return sendResponse({          data: { message: "user not connected" },          statusCode: 400,        });      api        .updateLead({          ...request.input,          token: credentials.token.value,          csrf: credentials.csrf,        })        .then(sendResponse)        .catch((result) => sendResponse(result));    }    if (request.action == "UPDATE_LEAD_INFOS") {      if (!credentials.token)        return sendResponse({          data: { message: "user not connected" },          statusCode: 400,        });      api        .updateLeadInfos({          ...request.input,          token: credentials.token.value,          csrf: credentials.csrf,        })        .then(sendResponse)        .catch((result) => sendResponse(result));    }    if (request.action == "DELETE_LEAD") {      if (!credentials.token)        return sendResponse({          data: { message: "user not connected" },          statusCode: 400,        });      api        .deleteLead({          ...request.input,          token: credentials.token.value,          csrf: credentials.csrf,        })        .then(sendResponse)        .catch((result) => sendResponse(result));    }  });  return true;});